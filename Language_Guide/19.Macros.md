# 宏
##### 用宏在编译时生成代码

宏在编译时转换你的源代码，可以让你避免编写重复的代码。在汇编过程中，Swift在常规构建代码之前，会展开宏。

<p align="center">
<img src="https://docs.swift.org/swift-book/images/org.swift.tspl/macro-expansion@2x.png" alt="宏" width="414"/>
</p>

展开宏是一种添加操作：宏会增加新代码，但不会删除会修改代码。

宏的输出和输入都会被检查，以确保他们是语法有效的 Swift 代码。比如，你传递给宏和宏生成的值都会被检查，以确保它们有正确的类型。另外，当展开宏的时候发现其实现遇到问题，编译器认为出现了汇编错误。这些确保使得使用宏的代码容易推理，也让定位不正确地使用宏和实现有bug的宏的错误变得容易。

Swift有两种宏：
- 独立宏自行出现，无需附加任何声明。
- 附加宏修改它们修饰的声明

调用独立宏和附加宏的方式略微不同，但它们都遵从同样的宏展开模型，你用同样的方法实现它们。下面的章节更详细地描述了这两种宏。

## 独立宏

要调用独立宏，在其名称前面写上数字符号（`#`），然后在名称后面的括号中写上参数。例如：
```swift
func myFunction() {
    print("Currently running \(#function)")
    #warning("Something's wrong")
}
```

在第一行，`#function`调用Swift标准库中的`function()`宏。当你编译这些代码，Swift调用该宏的实现，即用当前函数名替换`#function`。当你运行代码，调用`myFunction()`函数，会输出"Currently running myFunction()"。第二行，`#warning`调用Swift标准款中的宏`warning(_:)`产生一条自定义编译时警告。

## 附加宏

要调用附加宏，在其名称前面写上`@`符号，然后在名称后面的括号中写上参数。

附加宏会修改其修饰的声明。它会向声明中添加代码，如定义新方法或向`Protocol`中添加实现。

例如，看下下面没有用宏的例子：
```swift
struct SundaeToppings: OptionSet {
    let rawValue: Int
    static let nuts = SundaeToppings(rawValue: 1 << 0)
    static let cherry = SundaeToppings(rawValue: 1 << 1)
    static let fudge = SundaeToppings(rawValue: 1 << 2)
}
```

在代码中，`SundaeToppings`选项集中的每个选项都调用了初始化方法，这些是重复的手动的。添加新选项的时候非常容易出错，如在行末输入错误的数字。

下面是使用宏的版本：
```swift
@OptionSet<Int>
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }
}
```

这个版本的`SundaeToppings`调用了`@OptionSet`宏。这个宏会调用私有枚举中的分支列表，为每个选项生成常量列表，然后实现`OptionSet`协议。

作为对比，下面是`@OptionSet`宏的展开版本。你不必编写这些代码，只有当你让Swift展开宏的时候才会看到这些实现。
```swift
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }

    typealias RawValue = Int
    var rawValue: RawValue
    init() { self.rawValue = 0 }
    init(rawValue: RawValue) { self.rawValue = rawValue }
    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)
    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)
    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)
}
extension SundaeToppings: OptionSet {}
```

私有枚举中的所有代码都来自`@OptionSet`宏。用宏生成所有静态变量版本的`SundaeToppings`比手动编写的版本更加已读和易维护。

## 宏的声明